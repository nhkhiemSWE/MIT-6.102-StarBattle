"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const assert_1 = __importDefault(require("assert"));
const parser_1 = require("../internal/parser");
const types_1 = require("../internal/types");
const compiler_1 = require("../internal/compiler");
describe('nt and dot only', () => {
    it('should handle simple hand-constructed grammar', () => {
        // a ::= b
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.nt)(NT.b, 'b'));
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('x');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'x');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 1);
        assert_1.default.equal(tree.childrenByName(NT.a).length, 0);
        assert_1.default.equal(tree.childrenByName(NT.b).length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
        assert_1.default.equal(child.childrenByName(NT.a).length, 0);
        assert_1.default.equal(child.childrenByName(NT.b).length, 0);
    });
    it('should match entire string and entire grammar', () => {
        // a ::= b
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.nt)(NT.b, 'b'));
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        assert_1.default.throws(() => { parser.parse('xy'); }, types_1.ParseError);
        assert_1.default.throws(() => { parser.parse(''); }, types_1.ParseError);
    });
    it('should report missing nonterminal', () => {
        // a ::= b
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.nt)(NT.b, 'b'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        assert_1.default.throws(() => { parser.parse('xy'); }, types_1.ParseError);
    });
    it('dot should match newlines too', () => {
        // a ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('\n');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, '\n');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 0);
    });
});
describe('cat', () => {
    it('concatenation with two operands', () => {
        // a ::= b .
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.cat)((0, parser_1.nt)(NT.b, 'b'), (0, parser_1.regex)('.')));
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('xy');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'xy');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 2);
        assert_1.default.equal(tree.children.length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
    });
    it('should match entire string and entire hand-constructed grammar', () => {
        // a ::= b .
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.cat)((0, parser_1.nt)(NT.b, 'b'), (0, parser_1.regex)('.')));
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        //assert.throws(()=>{ parser.parse('xyz'); }, ParseError);
        assert_1.default.throws(() => { parser.parse('x'); }, types_1.ParseError);
    });
    it('empty concatenation', () => {
        // a ::= 
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.cat)());
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, '');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 0);
        assert_1.default.equal(tree.children.length, 0);
    });
});
describe('string literal', () => {
    it('should match string literals', () => {
        // a ::= b .
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.str)('abc'));
        definitions.set(NT.b, (0, parser_1.str)(''));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('abc');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'abc');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 3);
        assert_1.default.equal(tree.children.length, 0);
    });
    it('empty string', () => {
        // a ::= 
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.str)('abc'));
        definitions.set(NT.b, (0, parser_1.str)(''));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.b, 'b'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('');
        assert_1.default.equal(tree.name, NT.b);
        assert_1.default.equal(tree.text, '');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 0);
        assert_1.default.equal(tree.children.length, 0);
    });
});
describe('or', () => {
    it('or with two operands', () => {
        // a ::= b .
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.or)((0, parser_1.nt)(NT.b, 'b'), (0, parser_1.str)('y')));
        definitions.set(NT.b, (0, parser_1.str)('x'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('x');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'x');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
        const tree2 = parser.parse('y');
        assert_1.default.equal(tree2.name, NT.a);
        assert_1.default.equal(tree2.text, 'y');
        assert_1.default.equal(tree2.start, 0);
        assert_1.default.equal(tree2.end, 1);
        assert_1.default.equal(tree2.children.length, 0);
        assert_1.default.throws(() => { parser.parse('xy'); }, types_1.ParseError);
        assert_1.default.throws(() => { parser.parse('yx'); }, types_1.ParseError);
    });
    it('singleton or', () => {
        // a ::= 
        // b ::= .
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.or)((0, parser_1.nt)(NT.b, 'b')));
        definitions.set(NT.b, (0, parser_1.regex)('.'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('x');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'x');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
    });
});
describe('repeats', () => {
    it('repeat *', () => {
        // a ::= b*
        // b ::= 'x'
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.repeat)((0, parser_1.nt)(NT.b, 'b'), parser_1.ZERO_OR_MORE));
        definitions.set(NT.b, (0, parser_1.str)('x'));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('x');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'x');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
        const tree2 = parser.parse('xxx');
        assert_1.default.equal(tree2.name, NT.a);
        assert_1.default.equal(tree2.text, 'xxx');
        assert_1.default.equal(tree2.start, 0);
        assert_1.default.equal(tree2.end, 3);
        assert_1.default.equal(tree2.children.length, 3);
        parser.parse('');
        parser.parse('xxxxxx');
        assert_1.default.throws(() => { parser.parse('xy'); }, types_1.ParseError);
        assert_1.default.throws(() => { parser.parse('yx'); }, types_1.ParseError);
    });
    it('repeat + and ?', () => {
        // a ::= b+
        // b ::= 'x' 'y'?
        let NT;
        (function (NT) {
            NT[NT["a"] = 0] = "a";
            NT[NT["b"] = 1] = "b";
        })(NT || (NT = {}));
        ;
        const definitions = new Map();
        definitions.set(NT.a, (0, parser_1.repeat)((0, parser_1.nt)(NT.b, 'b'), parser_1.ONE_OR_MORE));
        definitions.set(NT.b, (0, parser_1.cat)((0, parser_1.str)('x'), (0, parser_1.repeat)((0, parser_1.str)('y'), parser_1.ZERO_OR_ONE)));
        const parser = new parser_1.InternalParser(definitions, (0, parser_1.nt)(NT.a, 'a'), (0, compiler_1.makeNonterminalConverters)(NT).nonterminalToString);
        const tree = parser.parse('x');
        assert_1.default.equal(tree.name, NT.a);
        assert_1.default.equal(tree.text, 'x');
        assert_1.default.equal(tree.start, 0);
        assert_1.default.equal(tree.end, 1);
        assert_1.default.equal(tree.children.length, 1);
        const child = tree.children[0];
        assert_1.default.equal(child.name, NT.b);
        assert_1.default.equal(child.text, 'x');
        assert_1.default.equal(child.start, 0);
        assert_1.default.equal(child.end, 1);
        assert_1.default.equal(child.children.length, 0);
        const tree2 = parser.parse('xxx');
        assert_1.default.equal(tree2.name, NT.a);
        assert_1.default.equal(tree2.text, 'xxx');
        assert_1.default.equal(tree2.start, 0);
        assert_1.default.equal(tree2.end, 3);
        assert_1.default.equal(tree2.children.length, 3);
        const tree3 = parser.parse('xyxxy');
        assert_1.default.equal(tree3.name, NT.a);
        assert_1.default.equal(tree3.text, 'xyxxy');
        assert_1.default.equal(tree3.start, 0);
        assert_1.default.equal(tree3.end, 5);
        assert_1.default.equal(tree3.children.length, 3);
        assert_1.default.throws(() => { parser.parse('xyy'); }, types_1.ParseError);
        assert_1.default.throws(() => { parser.parse(''); }, types_1.ParseError);
    });
});
//# sourceMappingURL=internal-test.js.map